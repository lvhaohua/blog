(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{494:function(t,_,v){"use strict";v.r(_);var a=v(15),r=Object(a.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("p",[t._v("冒泡排序、插入排序、选择排序、快速排序、归并排序、桶排序、计数排序、基数排序")]),t._v(" "),v("h2",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th"),t._v(" "),v("th",[t._v("时间复杂度")]),t._v(" "),v("th",[t._v("空间复杂度")]),t._v(" "),v("th",[t._v("是否稳定")]),t._v(" "),v("th")])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("冒泡排序")]),t._v(" "),v("td",[t._v("O(n^2)")]),t._v(" "),v("td",[t._v("O(1)")]),t._v(" "),v("td",[t._v("是")]),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td",[t._v("插入排序")]),t._v(" "),v("td",[t._v("O(n^2)")]),t._v(" "),v("td",[t._v("O(1)")]),t._v(" "),v("td",[t._v("是")]),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td",[t._v("选择排序")]),t._v(" "),v("td",[t._v("O(n^2)")]),t._v(" "),v("td",[t._v("O(1)")]),t._v(" "),v("td",[t._v("否")]),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td"),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td",[t._v("快速排序")]),t._v(" "),v("td",[t._v("O(nlogn)")]),t._v(" "),v("td",[t._v("O(logn)")]),t._v(" "),v("td",[t._v("否")]),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td",[t._v("归并排序")]),t._v(" "),v("td",[t._v("O(nlogn)")]),t._v(" "),v("td",[t._v("O(n)")]),t._v(" "),v("td",[t._v("是")]),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td"),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td")]),t._v(" "),v("tr",[v("td",[t._v("桶排序")]),t._v(" "),v("td",[t._v("O(n)")]),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td",[t._v("线性排序")])]),t._v(" "),v("tr",[v("td",[t._v("计数排序")]),t._v(" "),v("td",[t._v("O(n)")]),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td",[t._v("线性排序")])]),t._v(" "),v("tr",[v("td",[t._v("基数排序")]),t._v(" "),v("td",[t._v("O(n)")]),t._v(" "),v("td"),t._v(" "),v("td"),t._v(" "),v("td",[t._v("线性排序")])])])]),t._v(" "),v("h2",{attrs:{id:"排序算法的执行效率"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#排序算法的执行效率"}},[t._v("#")]),t._v(" 排序算法的执行效率")]),t._v(" "),v("h3",{attrs:{id:"_1-最好情况、最坏情况、平均情况时间复杂度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-最好情况、最坏情况、平均情况时间复杂度"}},[t._v("#")]),t._v(" 1. 最好情况、最坏情况、平均情况时间复杂度")]),t._v(" "),v("h3",{attrs:{id:"_2-时间复杂度的系数、常数-、低阶"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-时间复杂度的系数、常数-、低阶"}},[t._v("#")]),t._v(" 2. 时间复杂度的系数、常数 、低阶")]),t._v(" "),v("p",[t._v("我们知道，时间复杂度反映的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但是实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。")]),t._v(" "),v("h3",{attrs:{id:"_3-比较次数和交换-或移动-次数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-比较次数和交换-或移动-次数"}},[t._v("#")]),t._v(" 3. 比较次数和交换（或移动）次数")]),t._v(" "),v("p",[t._v("基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。")]),t._v(" "),v("h2",{attrs:{id:"排序算法的内存消耗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#排序算法的内存消耗"}},[t._v("#")]),t._v(" 排序算法的内存消耗")]),t._v(" "),v("p",[t._v("原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。")]),t._v(" "),v("h2",{attrs:{id:"排序算法的稳定性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#排序算法的稳定性"}},[t._v("#")]),t._v(" 排序算法的稳定性")]),t._v(" "),v("p",[t._v("稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。")]),t._v(" "),v("h2",{attrs:{id:"最适用的排序算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#最适用的排序算法"}},[t._v("#")]),t._v(" 最适用的排序算法")]),t._v(" "),v("h3",{attrs:{id:"_1-数据量小使用归并排序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-数据量小使用归并排序"}},[t._v("#")]),t._v(" 1. 数据量小使用归并排序")]),t._v(" "),v("h3",{attrs:{id:"_2-数据量大使用快速排序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-数据量大使用快速排序"}},[t._v("#")]),t._v(" 2. 数据量大使用快速排序")]),t._v(" "),v("h4",{attrs:{id:"_2-1-快排优化-三数取中法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-快排优化-三数取中法"}},[t._v("#")]),t._v(" 2.1 快排优化-三数取中法")]),t._v(" "),v("p",[t._v("三数取中法我们从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，肯定要比单纯取某一个数据更好。但是，如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”。")]),t._v(" "),v("h4",{attrs:{id:"_2-2-解决递归爆栈"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-解决递归爆栈"}},[t._v("#")]),t._v(" 2.2 解决递归爆栈")]),t._v(" "),v("p",[t._v("我们知道，快速排序是用递归来实现的。我们在递归那一节讲过，递归要警惕堆栈溢出。为了避免快速排序里，递归过深而堆栈过小，导致堆栈溢出，我们有两种解决办法：")]),t._v(" "),v("p",[t._v("第一种是限制递归深度。一旦递归过深，超过了我们事先设定的阈值，就停止递归。")]),t._v(" "),v("p",[t._v("第二种是通过在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程，这样就没有了系统栈大小的限制。")]),t._v(" "),v("p",[t._v("在快速排序的过程中，当要排序的区间中，元素的个数小于等于 4 时，qsort() 就退化为插入排序，不再继续用递归来做快速排序，"),v("strong",[t._v("在小规模数据面前，O(n2) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长")]),t._v("。")])])}),[],!1,null,null,null);_.default=r.exports}}]);