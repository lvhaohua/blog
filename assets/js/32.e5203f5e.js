(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{459:function(t,a,s){"use strict";s.r(a);var _=s(15),v=Object(_.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("从事 web 开发了解浏览器的渲染流程是很有必要的，下面来一起看看吧")]),t._v(" "),s("h2",{attrs:{id:"完整流程图"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#完整流程图"}},[t._v("#")]),t._v(" 完整流程图")]),t._v(" "),s("p",[t._v("首先来看一下从输入 URL 到页面展示的完整流程图")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://static001.geekbang.org/resource/image/92/5d/92d73c75308e50d5c06ad44612bcb45d.png",alt:""}})]),t._v(" "),s("p",[t._v("从图中可以看出，整个过程需要各个进程之间的配合，所以在开始正式流程之前，我们还是先来快速回顾下浏览器进程、渲染进程和网络进程的主要职责。")]),t._v(" "),s("h3",{attrs:{id:"浏览器进程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#浏览器进程"}},[t._v("#")]),t._v(" 浏览器进程")]),t._v(" "),s("p",[t._v("主要负责用户交互、子进程管理和文件储存等功能")]),t._v(" "),s("h3",{attrs:{id:"网络进程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#网络进程"}},[t._v("#")]),t._v(" 网络进程")]),t._v(" "),s("p",[t._v("面向渲染进程和浏览器进程等提供网络下载功能")]),t._v(" "),s("h3",{attrs:{id:"渲染进程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#渲染进程"}},[t._v("#")]),t._v(" 渲染进程")]),t._v(" "),s("p",[t._v("把从网络下载的 "),s("code",[t._v("HTML")]),t._v("、"),s("code",[t._v("JavaScript")]),t._v("、"),s("code",[t._v("CSS")]),t._v("、图片等资源解析为可以显示和交互的页面。因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。这也是为什么 Chrome 会让渲染进程运行在安全沙箱里，就是为了保证系统的安全。")]),t._v(" "),s("h2",{attrs:{id:"进程间的大致处理步骤"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进程间的大致处理步骤"}},[t._v("#")]),t._v(" 进程间的大致处理步骤")]),t._v(" "),s("ol",[s("li",[t._v("首先，浏览器进程接收到用户输入的 URL 请求，浏览器进程便将该 URL 转发给网络进程。")]),t._v(" "),s("li",[t._v("在网络进程中发起真正的 URL 请求。")]),t._v(" "),s("li",[t._v("接着网络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程。")]),t._v(" "),s("li",[t._v("浏览器进程接收到网络进程的响应头数据之后，发送**“提交导航 (CommitNavigation)”**消息到渲染进程。")]),t._v(" "),s("li",[t._v("渲染进程接收到**“提交导航(CommitNavigation)”**的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和网络进程建立数据管道。")]),t._v(" "),s("li",[t._v("最后渲染进程会向浏览器进程**“确认提交”**，这是告诉浏览器进程：“已经准备好接受和解析页面数据了”。")]),t._v(" "),s("li",[t._v("浏览器进程接收到渲染进程**“提交文档”**的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态。")])]),t._v(" "),s("h2",{attrs:{id:"输入-url-到页面展示详细步骤"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#输入-url-到页面展示详细步骤"}},[t._v("#")]),t._v(" 输入 URL 到页面展示详细步骤")]),t._v(" "),s("h3",{attrs:{id:"_1-用户输入"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-用户输入"}},[t._v("#")]),t._v(" 1. 用户输入")]),t._v(" "),s("p",[t._v("当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是"),s("strong",[t._v("搜索内容")]),t._v("，还是请求的 "),s("strong",[t._v("URL")]),t._v("。")]),t._v(" "),s("ul",[s("li",[t._v("搜索内容：地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL。")]),t._v(" "),s("li",[t._v("URL：地址栏会根据规则，把这段内容加上协议，合成为完整的 URL")])]),t._v(" "),s("p",[t._v("当用户输入关键字并键入回车之后，这意味着当前页面即将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行 "),s("code",[t._v("beforeunload")]),t._v(" 事件的机会，"),s("code",[t._v("beforeunload")]),t._v(" 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面，比如当前页面可能有未提交完成的表单等情况，因此用户可以通过 beforeunload 事件来取消导航，让浏览器不再执行任何后续工作。")]),t._v(" "),s("p",[t._v("当前页面没有监听 beforeunload 事件或者同意了继续后续流程，浏览器便开始加载新的地址，标签页上的图标便随即进入加载状态。但此时图中页面显示的依然是之前打开的页面内容，并没立即替换为新的页面。因为需要等待"),s("strong",[t._v("提交文档阶段")]),t._v("，页面内容才会被替换。")]),t._v(" "),s("h3",{attrs:{id:"_2-url-请求过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-url-请求过程"}},[t._v("#")]),t._v(" 2. URL 请求过程")]),t._v(" "),s("p",[t._v("接下来便进入了页面资源请求过程。浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程。")]),t._v(" "),s("h4",{attrs:{id:"_2-1-查找缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-查找缓存"}},[t._v("#")]),t._v(" 2.1 查找缓存")]),t._v(" "),s("p",[t._v("首先，网络进程会查找本地缓存是否缓存了该资源。")]),t._v(" "),s("p",[t._v("如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。")]),t._v(" "),s("h4",{attrs:{id:"_2-2-dns-解析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-dns-解析"}},[t._v("#")]),t._v(" 2.2 DNS 解析")]),t._v(" "),s("p",[t._v("这请求前的第一步是要进行 DNS 解析，以获取请求域名的服务器 IP 地址。")]),t._v(" "),s("h4",{attrs:{id:"_2-3-建立-tcp-连接"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-建立-tcp-连接"}},[t._v("#")]),t._v(" 2.3 建立 TCP 连接")]),t._v(" "),s("p",[t._v("在建立 TCP 连接之前，如果请求协议是 HTTPS，那么还需要建立 TLS 连接。")]),t._v(" "),s("p",[t._v("接下来才是利用 IP 地址和服务器建立 TCP 连接。")]),t._v(" "),s("h4",{attrs:{id:"_2-4-正式发起请求"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-正式发起请求"}},[t._v("#")]),t._v(" 2.4 正式发起请求")]),t._v(" "),s("p",[t._v("连接建立之后，浏览器端会构建请求行、请求头等信息，把域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。")]),t._v(" "),s("h4",{attrs:{id:"_2-5-网络进程解析响应头内容"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-网络进程解析响应头内容"}},[t._v("#")]),t._v(" 2.5 网络进程解析响应头内容")]),t._v(" "),s("p",[t._v("服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始"),s("strong",[t._v("解析响应头")]),t._v("的内容了。")]),t._v(" "),s("p",[s("strong",[t._v("重定向")])]),t._v(" "),s("blockquote",[s("p",[t._v("解析响应头时，如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始，如果响应行是 200，那么表示浏览器可以继续处理该请求。")])]),t._v(" "),s("p",[s("strong",[t._v("响应数据类型处理")])]),t._v(" "),s("blockquote",[s("p",[t._v("URL 请求的数据类型，有时候是一个下载类型，有时候是正常的 HTML 页面，浏览器会根据响应头里的 Content-Type 字段来区分。Content-Type 是 HTTP 头中一个非常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型，然后浏览器会根据 Content-Type 的值来决定如何显示响应体的内容。")]),t._v(" "),s("p",[t._v("Content-type：text/html 告诉浏览器，服务器返回的数据是 HTML 格式")]),t._v(" "),s("p",[t._v("Content-type：application/octet-stream 告诉浏览器数据为字节流类型，通常情况下，浏览器会按照下载类型来处理该请求")]),t._v(" "),s("p",[t._v("所以，不同 Content-Type 的后续处理流程也截然不同。如果 Content-Type 字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束。但如果是 HTML，那么浏览器则会继续进行导航流程。由于 Chrome 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。")])]),t._v(" "),s("h3",{attrs:{id:"_3-准备渲染进程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-准备渲染进程"}},[t._v("#")]),t._v(" 3. 准备渲染进程")]),t._v(" "),s("p",[t._v("默认情况下，浏览器会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。")]),t._v(" "),s("p",[t._v("如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程。其他情况下都会创建一个新的渲染进程。")]),t._v(" "),s("h3",{attrs:{id:"_4-提交文档"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-提交文档"}},[t._v("#")]),t._v(" 4. 提交文档")]),t._v(" "),s("p",[t._v("浏览器进程在这个阶段将网络进程接收到的 HTML 数据提交给渲染进程。")]),t._v(" "),s("ul",[s("li",[t._v("首先当"),s("strong",[t._v("浏览器进程")]),t._v("接收到"),s("strong",[t._v("网络进程")]),t._v("的"),s("strong",[t._v("响应头数据")]),t._v("之后，便向渲染进程发起“提交文档”的消息；")]),t._v(" "),s("li",[s("strong",[t._v("渲染进程")]),t._v("接收到“提交文档”的消息后，会和"),s("strong",[t._v("网络进程")]),t._v("建立传输数据的“管道”；")]),t._v(" "),s("li",[t._v("等文档数据传输完成之后，"),s("strong",[t._v("渲染进程")]),t._v("会返回“确认提交”的消息给"),s("strong",[t._v("浏览器进程")]),t._v("；")]),t._v(" "),s("li",[s("strong",[t._v("浏览器进程")]),t._v("在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。")])]),t._v(" "),s("p",[t._v("到这里，一个完整的"),s("strong",[t._v("导航")]),t._v("流程（步骤 1-4）就“走”完了，这之后就要进入渲染阶段了。")]),t._v(" "),s("h3",{attrs:{id:"_5-渲染阶段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-渲染阶段"}},[t._v("#")]),t._v(" 5. 渲染阶段")]),t._v(" "),s("p",[t._v("由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出像素。")]),t._v(" "),s("p",[t._v("按照渲染的时间顺序，流水线可分为如下几个子阶段：")]),t._v(" "),s("ul",[s("li",[t._v("构建 DOM 树")]),t._v(" "),s("li",[t._v("样式计算")]),t._v(" "),s("li",[t._v("布局阶段")]),t._v(" "),s("li",[t._v("分层")]),t._v(" "),s("li",[t._v("图层绘制")]),t._v(" "),s("li",[t._v("分块")]),t._v(" "),s("li",[t._v("光栅化")]),t._v(" "),s("li",[t._v("合成")])]),t._v(" "),s("p",[t._v("每个子阶段都会"),s("strong",[t._v("输入内容")]),t._v("，"),s("strong",[t._v("处理内容")]),t._v("，"),s("strong",[t._v("输出内容")]),t._v("。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://static001.geekbang.org/resource/image/97/37/975fcbf7f83cc20d216f3d68a85d0f37.png",alt:""}})]),t._v(" "),s("h4",{attrs:{id:"_5-1-构建-dom-树"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-构建-dom-树"}},[t._v("#")]),t._v(" 5.1 构建 DOM 树")]),t._v(" "),s("p",[t._v("因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://static001.geekbang.org/resource/image/12/79/125849ec56a3ea98d4b476c66c754f79.png",alt:""}})]),t._v(" "),s("p",[t._v("可以通过在控制台里面输入“document”查看完整的 DOM 树结构")]),t._v(" "),s("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://static001.geekbang.org/resource/image/47/73/47f57c3eee749dd838939bfe5dd64573.png"}}),t._v(" "),s("p",[t._v("图中的 document 就是 DOM 结构，你可以看到，DOM 和 HTML 内容几乎是一样的，但是和 HTML 不同的是，DOM 是保存在内存中树状结构，可以通过 JavaScript 来查询或修改其内容。")]),t._v(" "),s("p",[t._v("现在我们已经生成 DOM 树了，但是 DOM 节点的样式我们依然不知道，要让 DOM 节点拥有正确的样式，这就需要"),s("strong",[t._v("样式计算")]),t._v("了")]),t._v(" "),s("h4",{attrs:{id:"_5-2-样式计算-recalculate-style"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-样式计算-recalculate-style"}},[t._v("#")]),t._v(" 5.2 样式计算（Recalculate Style）")]),t._v(" "),s("p",[t._v("样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成。")]),t._v(" "),s("p",[s("strong",[t._v("1. 把 CSS 转换为浏览器能够理解的结构")])]),t._v(" "),s("p",[t._v("CSS 样式来源主要有三种：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("通过 link 引用的外部 CSS 文件")])]),t._v(" "),s("li",[s("p",[t._v("style 标签内的 css")])]),t._v(" "),s("li",[s("p",[t._v("元素的 style 属性内嵌的 CSS，内联 CSS")])])]),t._v(" "),s("p",[t._v("和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets（CSSOM）。")]),t._v(" "),s("p",[t._v("在控制台中输入“document.styleSheets”可以查看完整的 CSSOM 结构。")]),t._v(" "),s("p",[s("strong",[t._v("2. 标准化样式表中的属性值")])]),t._v(" "),s("p",[t._v("CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。")]),t._v(" "),s("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://static001.geekbang.org/resource/image/12/60/1252c6d3c1a51714606daa6bdad3a560.png"}}),t._v(" "),s("p",[s("strong",[t._v("3. 计算出 DOM 树中每个节点的具体样式")])]),t._v(" "),s("p",[t._v("样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的"),s("strong",[t._v("继承")]),t._v("和"),s("strong",[t._v("层叠")]),t._v("两个规则。这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。")]),t._v(" "),s("h4",{attrs:{id:"_5-3-布局阶段-layout"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-布局阶段-layout"}},[t._v("#")]),t._v(" 5.3 布局阶段（Layout）")]),t._v(" "),s("p",[t._v("通过以上的步骤，我们有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。那么接下来就需要"),s("strong",[t._v("计算出 DOM 树中可见元素的几何位置")]),t._v("，我们把这个计算过程叫做"),s("strong",[t._v("布局")]),t._v("。")]),t._v(" "),s("p",[t._v("Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算")]),t._v(" "),s("p",[s("strong",[t._v("1. 创建布局树")])]),t._v(" "),s("p",[t._v("你可能注意到了 DOM 树还含有很多不可见的元素，比如 head 标签，还有使用了 display:none 属性的元素。所以在显示之前，我们还要"),s("strong",[t._v("额外地构建一棵只包含可见元素布局树")]),t._v("。")]),t._v(" "),s("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://static001.geekbang.org/resource/image/8e/0e/8e48b77dd48bdc509958e73b9935710e.png"}}),t._v(" "),s("p",[t._v("为了构建布局树，浏览器大体上完成了下面这些工作：")]),t._v(" "),s("ul",[s("li",[t._v("遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；")]),t._v(" "),s("li",[t._v("不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，和属性包含 "),s("code",[t._v("dispaly:none")]),t._v(" 的 "),s("code",[t._v("body.p.span")]),t._v(" 元素")])]),t._v(" "),s("p",[s("strong",[t._v("2. 布局计算")])]),t._v(" "),s("p",[t._v("现在我们有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置了。")]),t._v(" "),s("blockquote",[s("p",[t._v("注：在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。")])]),t._v(" "),s("h4",{attrs:{id:"_5-4-分层"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-4-分层"}},[t._v("#")]),t._v(" 5.4 分层")]),t._v(" "),s("p",[t._v("浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。")]),t._v(" "),s("p",[t._v("因为页面中可能有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，所以渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。")]),t._v(" "),s("p",[t._v("可以通过浏览器提供的“layers”工具查看。")]),t._v(" "),s("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://static001.geekbang.org/resource/image/e8/61/e8a7e60a2a08e05239456284d2aa4061.png"}}),t._v(" "),s("p",[t._v("通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。如上图中的 span 标签没有专属图层，那么它们就从属于它们的父节点图层。但不管怎样，最终每一个节点都会直接或者间接地从属于一个层。")]),t._v(" "),s("p",[t._v("那么需要满足什么条件，渲染引擎才会为特定的节点创建新的图层呢？")]),t._v(" "),s("p",[s("strong",[t._v("1. 拥有层叠上下文属性的元素会被提升为单独的一层")])]),t._v(" "),s("p",[t._v("页面是个二维平面，但是层叠上下文能够让 HTML 元素具有三维概念，这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上。")]),t._v(" "),s("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://static001.geekbang.org/resource/image/a0/19/a03eb12053aac1ac496b61a424f20119.png"}}),t._v(" "),s("p",[t._v("从图中可以看出，明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。")]),t._v(" "),s("p",[s("strong",[t._v("2. 需要剪裁（clip）的地方也会被创建为图层")])]),t._v(" "),s("div",{staticClass:"language-html line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-html"}},[s("code",[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("style")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),s("span",{pre:!0,attrs:{class:"token style"}},[s("span",{pre:!0,attrs:{class:"token language-css"}},[t._v("\n  "),s("span",{pre:!0,attrs:{class:"token selector"}},[t._v("div")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v("width")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 200"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v("height")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" 200"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v("overflow")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" auto"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[t._v("background")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" gray"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("style")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("body")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("div")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("p")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("所以元素有了层叠上下文的属性或者需要被剪裁，那么就会被提升成为单独一层，你可以参看下图："),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("p")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("p")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("从上图我们可以看到，document层上有A和B层，而B层之上又有两个图层。这些图层组织在一起也是一颗树状结构。"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("p")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("p")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n      图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创建层树（Update LayerTree）。\n    "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("p")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("div")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("body")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br")])]),s("p",[t._v("在这里我们把 div 的大小限定为 200 _ 200 像素，而 div 里面的文字内容比较多，文字所显示的区域肯定会超出 200 _ 200 的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在 div 区域，下图是运行时的执行结果：")]),t._v(" "),s("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://static001.geekbang.org/resource/image/6a/0c/6a583733735edc1e4d7946740eb6fc0c.png"}}),t._v(" "),s("p",[t._v("出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。你可以参考下图：")]),t._v(" "),s("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://static001.geekbang.org/resource/image/7b/97/7b6ceaab23c6c6d8e5930864ff9d7097.png"}}),t._v(" "),s("p",[t._v("所以说，元素有了层叠上下文的属性或者需要被剪裁，满足其中任意一点，就会被提升成为单独一层。")]),t._v(" "),s("h4",{attrs:{id:"_5-5-图层绘制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-5-图层绘制"}},[t._v("#")]),t._v(" 5.5 图层绘制")]),t._v(" "),s("p",[t._v("图层绘制阶段，输出的内容是"),s("strong",[t._v("用来记录绘制顺序和绘制指令的待绘制列表")]),t._v("。")]),t._v(" "),s("p",[t._v("在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制。")]),t._v(" "),s("p",[t._v("试想一下，如果给你一张纸，让你先把纸的背景涂成蓝色，然后在中间位置画一个红色的圆，最后再在圆上画个绿色三角形。你会怎么操作呢？")]),t._v(" "),s("p",[t._v("通常，你会把你的绘制操作分解为三步：")]),t._v(" "),s("ol",[s("li",[t._v("绘制蓝色背景")]),t._v(" "),s("li",[t._v("在中间绘制一个红色的圆")]),t._v(" "),s("li",[t._v("再在圆上绘制绿色三角形")])]),t._v(" "),s("p",[t._v("渲染引擎实现图层的绘制与之类似，会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表")]),t._v(" "),s("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://static001.geekbang.org/resource/image/40/08/40825a55214a7990bba6b9bec6e54108.png"}}),t._v(" "),s("p",[t._v("从图中可以看出，绘制列表中的指令其实非常简单，就是让其执行一个简单的绘制操作，比如绘制粉色矩形或者黑色的线等。而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。"),s("strong",[t._v("所以在图层绘制阶段，输出的内容就是这些待绘制列表。")])]),t._v(" "),s("h4",{attrs:{id:"_5-6-栅格化-raster"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-6-栅格化-raster"}},[t._v("#")]),t._v(" 5.6 栅格化（raster）")]),t._v(" "),s("p",[t._v("当图层的"),s("strong",[t._v("绘制列表")]),t._v("准备好之后，主线程会把该绘制列表提交（commit）给"),s("strong",[t._v("合成线程")]),t._v("。")]),t._v(" "),s("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://static001.geekbang.org/resource/image/46/41/46d33b6e5fca889ecbfab4516c80a441.png"}}),t._v(" "),s("p",[t._v("通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做"),s("strong",[t._v("视口（viewport）")]),t._v("。")]),t._v(" "),s("p",[t._v("在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。")]),t._v(" "),s("p",[t._v("基于这个原因，"),s("strong",[t._v("合成线程会将图层划分为图块（tile）")]),t._v("，这些图块的大小通常是 256x256 或者 512x512。")]),t._v(" "),s("p",[t._v("然后"),s("strong",[t._v("合成线程会按照视口附近的图块来优先生成位图")]),t._v("，实际生成位图的操作是由栅格化来执行的。**所谓栅格化，是指将图块转换为位图。**而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。")]),t._v(" "),s("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://static001.geekbang.org/resource/image/d8/20/d8d77356211e12b47bb9f508e2db8520.png"}}),t._v(" "),s("p",[t._v("通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。而 GPU 操作是运行在 GPU 进程中，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作。")]),t._v(" "),s("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://static001.geekbang.org/resource/image/a8/87/a8d954cd8e4722ee03d14afaa14c3987.png"}}),t._v(" "),s("p",[t._v("从图中可以看出，渲染进程把生成图块的指令发送给 GPU，然后"),s("strong",[t._v("在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中")]),t._v("。")]),t._v(" "),s("h4",{attrs:{id:"_5-7-合成"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-7-合成"}},[t._v("#")]),t._v(" 5.7 合成")]),t._v(" "),s("p",[t._v("一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。")]),t._v(" "),s("p",[t._v("浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。")]),t._v(" "),s("p",[t._v("到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。")]),t._v(" "),s("h2",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),s("ol",[s("li",[t._v("构建 DOM Tree： 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。")]),t._v(" "),s("li",[t._v("构建 CSS OM：渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。")]),t._v(" "),s("li",[t._v("构建 Layout Tree：创建布局树，并计算元素的布局信息。")]),t._v(" "),s("li",[t._v("分层：对布局树进行分层，并生成分层树。")]),t._v(" "),s("li",[t._v("绘制：为每个图层生成绘制列表，并将其提交到合成线程。")]),t._v(" "),s("li",[t._v("栅格化：合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图，并将位图存储在 CPU 内存中。")]),t._v(" "),s("li",[t._v("合成：合成线程发送绘制图块命令 DrawQuad 给浏览器进程。")]),t._v(" "),s("li",[t._v("显示：浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。")])])])}),[],!1,null,null,null);a.default=v.exports}}]);